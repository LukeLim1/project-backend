import {getData, setData} from './dataStore';
import { userProfileV1 } from './users';

function channelInviteV1 (authUserId, channelId, uId) {
    return 'authUserId' + 'channelId' + 'uId';
}

function channelMessagesV1 (authUserId, channelId) {
    return 'authUserId' + 'channelId' + 'start';
}

// channelDetailsV1
// Given 2 parameters, authUserId and channelId, where the user with authUserId should be a member of the channel with channelId,
// prints out the details of the channel. 

// Parameters: authUserId: integer - This is the Id of a user which is initially generated by authRegisterV1 function
//             channelId: integer - Id of a channel that this function is trying to print detail of, and it's created by channelCreateV1

// Return type: { name, isPublic, ownerMembers, allMembers }
//              { error: 'error' } when any of the following:
//                  channelId is not referring to a channel existing in datastore
//                  channelId is valid, but the authorised user is not a member of the channel (i.e. authUserId not in ownerMembers nor allMembers)

export function channelDetailsV1 (authUserId, channelId) {
    const data = getData();
    const channel = data.channels.find(channel => channel.channelId === channelId);

    if (!channel) {
        return { error: 'error' };
    }

    const owner = data.users.find(o => o.userId === channel.ownerMembers[0]);
    const ownerArr = [{
        uId: owner.userId,
        email: owner.emailAddress,
        nameFirst: owner.name.split(' ')[0],
        nameLast: owner.name.split(' ')[1],
        handleStr: owner.handle,
    }];
    const userArr = [];


    //check if user with authUserId belongs to channel with channelId
    if (!channel.allMembers.includes(authUserId)) {
        return { error: 'error' };
    }

    for (const member of channel.allMembers) {
        const user = data.users.find(u => u.userId === member)
        const userObj = {
            uId: user.userId,
            email: user.emailAddress,
            nameFirst: user.name.split(' ')[0],
            nameLast: user.name.split(' ')[1],
            handleStr: user.handle,
        }
        userArr.push(userObj);
    }


    return {
        name: channel.name,
        isPublic: channel.isPublic,
        ownerMembers: ownerArr,
        allMembers: userArr,
    }
}


//channelJoinV1
// Given 2 parameters, authUserId and channelId, joins a user with authUserId to the channel with channelId (in allMembers array)

// Parameters: authUserId: integer - Id of a user who wants to join channel, which is initially generated by authRegisterV1 function
//             channelId: integer - Id of a channel, and it's created by channelCreateV1

// Return type: none
//              { error: 'error' } when any of the following:
//                  channelId is not referring to a channel existing in datastore
//                  authorized user is already a member of the channel (i.e. authUserId is already existing in channel. 
//                                                                      In our case it's in allMembers array)
//                  channelId refers to a private channel, and the authrized user is not a channel member and not a global owner

export function channelJoinV1 (authUserId, channelId) {
    const data = getData();
    const channel = data.channels.find(channel => channel.channelId === channelId);
    const user = userProfileV1(authUserId, authUserId);

    if (!channel) {
        return { error: 'error' };
    }   
    
    if (channel.isPublic === false) {
        return { error: 'error' };
    } else if (channel.allMembers.includes(authUserId)) {
        return { error: 'error' };
    }

    channel.allMembers.push(user.uId);
    setData(data);
}